## 深入响应式原理

### 响应式对象

响应式对象核心就是利用 `Object.defineProperty` 给数据添加了 getter 和 setter 来用于依赖收集和派发更新。

#### initState

在 Vue 的初始化阶段，`_init` 方法执行的时候，会执行 `initState(vm)` 方法，主要是对 props、methods、data、computed 和 watcher 等属性做了初始化操作。

`initProps` 主要过程就是遍历定义的 props 配置。遍历的过程主要做两件事情：
1. 调用 `defineReactive` 方法把每个 prop 对应的值变成响应式，可以通过 `vm._props.xxx` 访问到定义 props 中对应的属性。
2. 通过 `proxy` 把 `vm._props.xxx` 的访问代理到 `vm.xxx` 上。

`initData` 主要过程也是遍历定义 data 函数的返回对象，遍历的过程主要做两件事：
1. 通过 `proxy` 把 `vm._data.xxx` 的访问代理到 `vm.xxx` 上。
2. 调用 `observe` 方法观测整个 data 的变化，把 data 也变成响应式，可以通过 `vm._data.xxx` 访问到定义 data 返回函数中对应的属性。

#### observe

`observe` 的功能就是用来监测数据的变化。通过给非 VNode 的对象类型数据添加一个 `Observer`，
如果已经添加过则直接返回，否则在满足一定条件下去实例化一个 `Observer` 对象实例。

#### Observer

`Observer` 是一个类，构造函数的逻辑首先实例化 `Dep` 对象，
然后根据 value 的类型做判断，对于数组会调用 `observeArray` 方法，否则对纯对象调用 walk 方法。
其中 `observeArray` 是遍历数组再次调用 `observe` 方法，而 `walk` 方法是遍历对象的 key 调用 `defineReactive` 方法。

#### defineReactive

`defineReactive` 函数最开始初始化 `Dep` 对象的实例，
接着拿到 obj 的属性描述符，
然后对子对象 `childOb` 递归调用 `observe` 方法，
最后利用 `Object.defineProperty` 去给 obj 的属性 key 添加 getter 和 setter 来用于依赖收集和派发更新。


### 依赖收集

依赖收集就是订阅数据变化的 `Watcher` 的收集。

收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理。

#### Dep

`Dep` 是一个 Class，`Dep` 实际上就是对 `Watcher` 的一种管理。

### Watcher

`Watcher` 是一个 Class，在它的构造函数中，定义了一些和 `Dep` 相关的属性：
* 其中，`this.deps` 和 `this.newDeps` 表示 `Watcher` 实例持有的 `Dep` 实例的数组；
* 而 `this.depIds` 和 `this.newDepIds` 分别代表 `this.deps` 和 `this.newDeps` 的 id Set。

`Watcher` 还定义了一些原型的方法，和依赖收集相关的有 `get`、`addDep` 和 `cleanupDeps` 方法。

#### 依赖收集的过程分析

> 参见文档


### 派发更新

派发更新就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程。

派发更新的过程中会把所有要执行 update 的 watcher 推入到队列中，在 nextTick 后执行 flush 来触发 watcher.run()，并在最后执行 watcher 的回调函数。

#### 派发更新的过程分析

> 参见文档


### nextTick

nextTick 的降级实现依次为 Promise / MutationObserver / setImmediate / setTimeout。

数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。


### 检测变化的注意事项

#### 通过 Vue.set 对象添加属性

通过 `defineReactive(ob.value, key, val)` 把新添加的属性变成响应式对象，然后再通过 `ob.dep.notify()` 手动的触发依赖通知。

> 如何收集依赖？
> 在 getter 过程中判断了 childOb，并调用了 childOb.dep.depend() 收集了依赖，这就是为什么执行 Vue.set 的时候通过 ob.dep.notify() 能够通知到 watcher，从而让添加新的属性到对象也可以检测到变化。

#### 数组的处理

重写数组原型，并对能增加数组长度的 3 个方法 `push、unshift、splice` 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象，并且再调用 `ob.dep.notify()` 手动触发依赖通知。


### computed & watch

#### computed

计算属性本质上是一个 `computed watcher(lazy=true)`。

当计算属性的依赖项发生改变才会计算，当计算的值发生变化才会触发渲染。

#### watch

侦听属性本质上是一个 `user watcher(user=true)`。watch 最终会调用 $watch 方法创建 watcher。

当我们 watch 的数据发送变化，它最终会执行 watcher 的 run 方法，执行回调函数 cb。

watch option deep 会触发 `traverse(value)` 来做深层递归遍历，遍历过程中对子对象的访问会触发它们的 getter 过程，这样就可以收集到依赖，也就是订阅它们变化的 watcher，
当再对 watch 的对象内部任何一个值做修改，也会调用 watcher 的回调函数了。

但是因为设置了 deep 后会执行 traverse 函数，会有一定的性能开销，所以一定要根据应用场景权衡是否要开启这个配置。


### 组件更新


