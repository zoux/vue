## 扩展

### event

Vue 支持 2 种事件类型，原生 DOM 事件和自定义事件。它们主要的区别在于添加和删除事件的方式不一样(addEventListener/$on)。

自定义事件的派发是往当前实例上派发，但是可以利用在父组件环境定义回调函数来实现父子组件的通讯。

> 父组件传入 listeners，然后在执行 initEvents 的过程中，会处理这个 listeners。之后子组件 $emit 来执行 $options._parentListeners 上即传入的事件。

只有组件节点才可以添加自定义事件，并且添加原生 DOM 事件需要使用 native 修饰符；而普通元素使用 .native 修饰符是没有作用的，也只能添加原生 DOM 事件。


### v-model

input 实现 v-model 的精髓，通过修改 AST 元素，来借助 `addProp` 和 `addHandler`给 el 添加了值和事件。

这样实际上就完成了数据双向绑定了，所以说 v-model 实际上就是语法糖。

```vue
<input v-bind:value="message" v-on:input="message=$event.target.value" />
```


### slot

普通插槽/作用域插槽的目的都是让子组件 slot 占位符生成的内容由父组件来决定，但数据的作用域会根据它们 vnodes 渲染时机不同而不同。

普通插槽是在父组件编译和渲染阶段生成 vnodes，所以数据的作用域是父组件实例，子组件渲染的时候直接拿到这些渲染好的 vnodes。

作用域插槽，父组件在编译和渲染阶段并不会直接生成 vnodes，而是在父节点保留 vnode.data.scopedSlots 对象，存储着不同名称的插槽以及它们对应的渲染函数。
只有在编译和渲染子组件阶段才会执行这个渲染函数生成 vnodes，由于是在子组件环境执行的，所以对应的数据作用域是子组件实例。


### keep-alive

keep-alive 组件是一个抽象组件(`abstract: true`)，它的实现通过自定义 render 函数并且利用了 slot。

keep-alive 只处理第一个子元素，所以一般和它搭配使用的有 `component` 动态组件或者是 `router-view`。

#### 组件渲染

对于首次渲染而言，除了在 keep-alive 中建立缓存，和普通组件渲染没什么区别。

对于二次渲染而言，由于 keep-alive 组件本质上支持了 slot，所以它执行 `prepatch` 的时候会触发 `$forceUpdate` 逻辑，
也就是重新执行 keep-alive 的 render 方法，这个时候如果它包裹的第一个组件 vnode 命中缓存，则直接返回缓存。


### transition

略。


### transition-group

略。
