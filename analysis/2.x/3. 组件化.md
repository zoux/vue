## 组件化

### createComponent

createComponent 后返回的是组件 vnode，它也一样走到 vm._update 方法，进而执行了 patch 函数。

createComponent 的关键步骤：
1. 构造子类构造函数。`Ctor = baseCtor.extend(Ctor)`
2. 安装组件钩子函数。用于在 VNode 执行 patch 的过程中执行相关的钩子函数。`installComponentHooks(data)`
3. 实例化 vnode。
    ```javascript
    const vnode = new VNode(
      `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
      data, undefined, undefined, undefined, context,
      { Ctor, propsData, listeners, tag, children },
      asyncFactory
    )
    return vnode
    ```

> Vue.extend 的作用就是构造一个 Vue 的子类。


### patch

组件同样从 `vm.__patch__` 开始，经过 createElm、createComponent、init(利用 createComponentInstanceForVnode 创建一个 Vue 的实例，然后调用 child.$mount 方法挂载子组件)。

> createComponentInstanceForVnode 中的 vnode.componentOptions.Ctor 对应的就是子组件的构造函数；
> activeInstance 为当前激活的 vm 实例；vm.$vnode 为组件的占位节点的 VNode；vm._vnode 为组件的真实渲染 VNode。

> 创建实例时通过触发 Vue.prototype._init 中的 initInternalComponent 来给组件的 $options 赋值。

> createComponent 遍历子节点，若为非组件节点则 createChildren 创建子元素，若为组件节点则递归调用 createComponent。


### 合并配置

options 的合并有 2 种方式，子组件初始化过程通过 initInternalComponent 方式要比外部初始化 Vue 通过 mergeOptions 的过程要快，合并完的结果保留在 vm.$options 中。


### 生命周期

生命周期函数就是在初始化及数据更新过程各个阶段执行不同的钩子函数。`callHook(vm, ${hookName})`

created 钩子函数中可以访问到数据，在 mounted 钩子函数中可以访问到 DOM，在 destroy 钩子函数中可以做一些定时器销毁工作。


### 组件注册

全局注册通过 Vue.component 将组件的参数 option 通过 extend 构建成构造器，并挂载到 Vue.options.components 中。
创建组件 VNode 是通过 _createElement 中的 resolveAsset(context.$options, 'components', tag) 获取到组件构造器作为 createComponent 的参数。

局部注册在组件的 Vue 的实例化阶段有一个 mergeOptions 的逻辑，把 option components 合并到 vm.$options.components 上，这样就可以走 createElement -> createComponent 的创建途径了。

局部注册和全局注册不同的是，只有该类型的组件才可以访问局部注册的子组件，
而全局注册是扩展到 Vue.options 下，所以在所有组件创建的过程中，都会从全局的 Vue.options.components 扩展到当前组件的 vm.$options.components 下，这就是全局注册的组件能被任意使用的原因。


### 异步组件

异步组件实现的本质是 2 次渲染。除了 0 delay 的高级异步组件第一次直接渲染成 loading 组件外，其它都是第一次渲染中因 `resolveAsyncComponent` 返回了 `undefined` 来促使 `createAsyncPlaceholder` 生成一个注释节点。

当异步获取组件成功后，再通过 `forceRender` 触发 `$forceUpdate` 强制重新渲染，此时再一次执行 `resolveAsyncComponent` 返回了最终状态的 `Ctor`。

`$forceUpdate` 的逻辑非常简单，就是调用渲染 watcher 的 `update` 方法，让渲染 watcher 对应的回调函数执行，也就是触发了组件的重新渲染。
